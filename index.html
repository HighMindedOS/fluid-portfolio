<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Interactive Background</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: #ffffff;
        }

        #fluid-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Content Layer */
        .content {
            position: relative;
            z-index: 10;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        /* Logo als Negativ-Bereich */
        .logo-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            pointer-events: auto;
        }

        /* Beispiel-Logo (kann durch SVG ersetzt werden) */
        .logo {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            font-family: Arial, sans-serif;
            color: #333;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }

        /* Interaktive Elemente */
        .nav-elements {
            position: absolute;
            top: 40px;
            left: 40px;
            pointer-events: auto;
        }

        .nav-link {
            display: inline-block;
            margin-right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            color: #333;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-family: Arial, sans-serif;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
            z-index: 100;
        }

        .control-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            margin-left: 10px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
        }

        /* Mobile Fallback */
        @media (max-width: 768px) {
            .mobile-message {
                position: fixed;
                bottom: 20px;
                left: 20px;
                right: 20px;
                background: rgba(255, 255, 255, 0.9);
                padding: 15px;
                border-radius: 10px;
                text-align: center;
                z-index: 1000;
                display: none;
            }
        }

        /* Credits */
        .credits {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: #666;
            font-family: Arial, sans-serif;
            z-index: 100;
        }

        .credits a {
            color: #666;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <canvas id="fluid-canvas"></canvas>
    
    <div class="content">
        <!-- Navigation mit Hover-Effekten -->
        <nav class="nav-elements">
            <a href="#" class="nav-link" data-color="#FF6B6B">Projekte</a>
            <a href="#" class="nav-link" data-color="#4ECDC4">Über uns</a>
            <a href="#" class="nav-link" data-color="#45B7D1">Kontakt</a>
            <a href="#" class="nav-link" data-color="#FFA07A">Services</a>
        </nav>

        <!-- Logo als Negativ-Bereich -->
        <div class="logo-container">
            <div class="logo" id="logo-element">LOGO</div>
        </div>
    </div>

    <!-- Steuerungselemente -->
    <div class="controls">
        <button class="control-btn" id="toggle-effect">Effekt pausieren</button>
        <button class="control-btn" id="clear-canvas">Zurücksetzen</button>
    </div>

    <!-- Credits (MIT Lizenz) -->
    <div class="credits">
        Based on <a href="https://github.com/PavelDoGreat/WebGL-Fluid-Simulation" target="_blank">WebGL Fluid Simulation</a> by Pavel Dobryakov (MIT License)
    </div>

    <script>
        'use strict';

        // Globale Konfiguration
        const config = {
            SIM_RESOLUTION: 128,
            DYE_RESOLUTION: 512,
            CAPTURE_RESOLUTION: 512,
            DENSITY_DISSIPATION: 0.97,
            VELOCITY_DISSIPATION: 0.98,
            PRESSURE: 0.8,
            PRESSURE_ITERATIONS: 20,
            CURL: 30,
            SPLAT_RADIUS: 0.25,
            SPLAT_FORCE: 6000,
            SHADING: true,
            COLORFUL: false,
            COLOR_UPDATE_SPEED: 10,
            PAUSED: false,
            BACK_COLOR: { r: 1, g: 1, b: 1 }, // Weißer Hintergrund
            TRANSPARENT: false,
            BLOOM: false,
            currentColor: { r: 0.2, g: 0.5, b: 0.8 } // Standard-Farbe
        };

        // Canvas Setup
        const canvas = document.getElementById('fluid-canvas');
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        let pointers = [];
        let splatStack = [];
        let logoMask = null;

        // WebGL Context
        function getWebGLContext(canvas) {
            const params = { 
                alpha: true, 
                depth: false, 
                stencil: false, 
                antialias: false,
                preserveDrawingBuffer: false,
                powerPreference: "high-performance"
            };

            let gl = canvas.getContext('webgl2', params);
            const isWebGL2 = !!gl;
            if (!isWebGL2)
                gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

            let halfFloat;
            let supportLinearFiltering;
            if (isWebGL2) {
                gl.getExtension('EXT_color_buffer_float');
                supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
            } else {
                halfFloat = gl.getExtension('OES_texture_half_float');
                supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
            }

            gl.clearColor(1.0, 1.0, 1.0, 1.0);

            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;
            let formatRGBA;
            let formatRG;
            let formatR;

            if (isWebGL2) {
                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
            } else {
                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            }

            return {
                gl,
                ext: {
                    formatRGBA,
                    formatRG,
                    formatR,
                    halfFloatTexType,
                    supportLinearFiltering
                }
            };
        }

        function getSupportedFormat(gl, internalFormat, format, type) {
            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                switch (internalFormat) {
                    case gl.R16F:
                        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                    case gl.RG16F:
                        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                    default:
                        return null;
                }
            }

            return { internalFormat, format };
        }

        function supportRenderTextureFormat(gl, internalFormat, format, type) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);

            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.deleteTexture(texture);
            gl.deleteFramebuffer(fbo);

            return status === gl.FRAMEBUFFER_COMPLETE;
        }

        const { gl, ext } = getWebGLContext(canvas);

        // Shader compilation
        function compileShader(type, source, keywords) {
            source = addKeywords(source, keywords);

            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                console.error(gl.getShaderInfoLog(shader));

            return shader;
        }

        function addKeywords(source, keywords) {
            if (keywords == null) return source;
            let keywordsString = '';
            keywords.forEach(keyword => {
                keywordsString += '#define ' + keyword + '\n';
            });
            return keywordsString + source;
        }

        // Shader-Quellcode
        const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
            precision highp float;

            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform vec2 texelSize;

            void main () {
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `);

        const copyShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;

            varying highp vec2 vUv;
            uniform sampler2D uTexture;

            void main () {
                gl_FragColor = texture2D(uTexture, vUv);
            }
        `);

        const clearShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;

            varying highp vec2 vUv;
            uniform sampler2D uTexture;
            uniform float value;

            void main () {
                gl_FragColor = value * texture2D(uTexture, vUv);
            }
        `);

        const displayShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;

            varying vec2 vUv;
            uniform sampler2D uTexture;
            uniform sampler2D uMask;

            void main () {
                vec4 color = texture2D(uTexture, vUv);
                vec4 mask = texture2D(uMask, vUv);
                
                // Maske anwenden - wo die Maske weiß ist, wird keine Farbe angezeigt
                color.rgb *= (1.0 - mask.r);
                
                // Weißer Hintergrund mit Fluid-Farbe
                gl_FragColor = vec4(1.0 - (1.0 - color.rgb) * color.a, 1.0);
            }
        `);

        const splatShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;

            varying vec2 vUv;
            uniform sampler2D uTarget;
            uniform sampler2D uMask;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;

            void main () {
                vec4 mask = texture2D(uMask, vUv);
                
                // Wenn Maske vorhanden, keine Farbe hinzufügen
                if (mask.r > 0.5) {
                    gl_FragColor = texture2D(uTarget, vUv);
                    return;
                }
                
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `);

        const advectionShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;

            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform sampler2D uMask;
            uniform vec2 texelSize;
            uniform vec2 dyeTexelSize;
            uniform float dt;
            uniform float dissipation;

            vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
                vec2 st = uv / tsize - 0.5;

                vec2 iuv = floor(st);
                vec2 fuv = fract(st);

                vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
                vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
                vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
                vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);

                return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
            }

            void main () {
                vec4 mask = texture2D(uMask, vUv);
                
                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
                vec4 result = dissipation * bilerp(uSource, coord, dyeTexelSize);
                
                // Maske berücksichtigen - Farbe fließt um Maske herum
                if (mask.r > 0.5) {
                    result = vec4(0.0);
                }
                
                gl_FragColor = result;
            }
        `, ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']);

        const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;

            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uVelocity;
            uniform sampler2D uMask;

            void main () {
                float L = texture2D(uVelocity, vL).x;
                float R = texture2D(uVelocity, vR).x;
                float T = texture2D(uVelocity, vT).y;
                float B = texture2D(uVelocity, vB).y;

                vec2 C = texture2D(uVelocity, vUv).xy;
                
                // Maske berücksichtigen
                vec4 mask = texture2D(uMask, vUv);
                if (mask.r > 0.5) {
                    L = C.x;
                    R = C.x;
                    T = C.y;
                    B = C.y;
                }

                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `);

        const curlShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;

            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uVelocity;

            void main () {
                float L = texture2D(uVelocity, vL).y;
                float R = texture2D(uVelocity, vR).y;
                float T = texture2D(uVelocity, vT).x;
                float B = texture2D(uVelocity, vB).x;
                float vorticity = R - L - T + B;
                gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
            }
        `);

        const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;

            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;
            uniform sampler2D uCurl;
            uniform float curl;
            uniform float dt;

            void main () {
                float L = texture2D(uCurl, vL).x;
                float R = texture2D(uCurl, vR).x;
                float T = texture2D(uCurl, vT).x;
                float B = texture2D(uCurl, vB).x;
                float C = texture2D(uCurl, vUv).x;

                vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                force /= length(force) + 0.0001;
                force *= curl * C;
                force.y *= -1.0;

                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity += force * dt;
                velocity = min(max(velocity, -1000.0), 1000.0);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `);

        const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;

            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
            uniform sampler2D uMask;

            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                float C = texture2D(uPressure, vUv).x;
                float divergence = texture2D(uDivergence, vUv).x;
                
                // Maske berücksichtigen
                vec4 mask = texture2D(uMask, vUv);
                if (mask.r > 0.5) {
                    gl_FragColor = vec4(0.0);
                    return;
                }
                
                float pressure = (L + R + B + T - divergence) * 0.25;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
        `);

        const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;

            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
            uniform sampler2D uMask;

            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                
                // Maske berücksichtigen - Geschwindigkeit an Grenzen auf 0 setzen
                vec4 mask = texture2D(uMask, vUv);
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                
                if (mask.r > 0.5) {
                    velocity = vec2(0.0);
                } else {
                    velocity -= vec2(R - L, T - B);
                }
                
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `);

        // Program creation
        class Program {
            constructor(vertexShader, fragmentShader) {
                this.uniforms = {};
                this.program = gl.createProgram();

                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))
                    console.error(gl.getProgramInfoLog(this.program));

                const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    const uniformName = gl.getActiveUniform(this.program, i).name;
                    this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);
                }
            }

            bind() {
                gl.useProgram(this.program);
            }
        }

        const copyProgram = new Program(baseVertexShader, copyShader);
        const clearProgram = new Program(baseVertexShader, clearShader);
        const displayProgram = new Program(baseVertexShader, displayShader);
        const splatProgram = new Program(baseVertexShader, splatShader);
        const advectionProgram = new Program(baseVertexShader, advectionShader);
        const divergenceProgram = new Program(baseVertexShader, divergenceShader);
        const curlProgram = new Program(baseVertexShader, curlShader);
        const vorticityProgram = new Program(baseVertexShader, vorticityShader);
        const pressureProgram = new Program(baseVertexShader, pressureShader);
        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);

        // FBO creation
        function createFBO(w, h, internalFormat, format, type, param) {
            gl.activeTexture(gl.TEXTURE0);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const texelSizeX = 1.0 / w;
            const texelSizeY = 1.0 / h;

            return {
                texture,
                fbo,
                width: w,
                height: h,
                texelSizeX,
                texelSizeY,
                attach(id) {
                    gl.activeTexture(gl.TEXTURE0 + id);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    return id;
                }
            };
        }

        function createDoubleFBO(w, h, internalFormat, format, type, param) {
            let fbo1 = createFBO(w, h, internalFormat, format, type, param);
            let fbo2 = createFBO(w, h, internalFormat, format, type, param);

            return {
                width: w,
                height: h,
                texelSizeX: fbo1.texelSizeX,
                texelSizeY: fbo1.texelSizeY,
                get read() {
                    return fbo1;
                },
                set read(value) {
                    fbo1 = value;
                },
                get write() {
                    return fbo2;
                },
                set write(value) {
                    fbo2 = value;
                },
                swap() {
                    let temp = fbo1;
                    fbo1 = fbo2;
                    fbo2 = temp;
                }
            }
        }

        // Resolution setup
        const resizeCanvas = () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                initFramebuffers();
                createLogoMask();
            }
        };

        function initFramebuffers() {
            const simRes = config.SIM_RESOLUTION;
            const dyeRes = config.DYE_RESOLUTION;
            const simFormat = ext.formatRG;
            const dyeFormat = ext.formatRGBA;
            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

            gl.disable(gl.BLEND);

            if (dye == null)
                dye = createDoubleFBO(dyeRes, dyeRes, dyeFormat.internalFormat, dyeFormat.format, ext.halfFloatTexType, filtering);
            else
                dye = resizeDoubleFBO(dye, dyeRes, dyeRes, dyeFormat.internalFormat, dyeFormat.format, ext.halfFloatTexType, filtering);

            if (velocity == null)
                velocity = createDoubleFBO(simRes, simRes, simFormat.internalFormat, simFormat.format, ext.halfFloatTexType, filtering);
            else
                velocity = resizeDoubleFBO(velocity, simRes, simRes, simFormat.internalFormat, simFormat.format, ext.halfFloatTexType, filtering);

            divergence = createFBO(simRes, simRes, ext.formatR.internalFormat, ext.formatR.format, ext.halfFloatTexType, gl.NEAREST);
            curl = createFBO(simRes, simRes, ext.formatR.internalFormat, ext.formatR.format, ext.halfFloatTexType, gl.NEAREST);
            pressure = createDoubleFBO(simRes, simRes, ext.formatR.internalFormat, ext.formatR.format, ext.halfFloatTexType, gl.NEAREST);
        }

        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {
            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);
            target.write = createFBO(w, h, internalFormat, format, type, param);
            target.width = w;
            target.height = h;
            target.texelSizeX = 1.0 / w;
            target.texelSizeY = 1.0 / h;
            return target;
        }

        function resizeFBO(target, w, h, internalFormat, format, type, param) {
            const newFBO = createFBO(w, h, internalFormat, format, type, param);
            copyProgram.bind();
            gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
            blit(newFBO.fbo);
            return newFBO;
        }

        let dye;
        let velocity;
        let divergence;
        let curl;
        let pressure;

        // Logo-Maske erstellen
        function createLogoMask() {
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = canvas.width;
            maskCanvas.height = canvas.height;
            const ctx = maskCanvas.getContext('2d');

            // Schwarzer Hintergrund
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

            // Weißer Kreis für Logo-Position
            const logo = document.getElementById('logo-element');
            const rect = logo.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = rect.width / 2;

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 20, 0, Math.PI * 2); // +20px für Abstand
            ctx.fill();

            // Texture erstellen
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);

            logoMask = {
                texture,
                attach(id) {
                    gl.activeTexture(gl.TEXTURE0 + id);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    return id;
                }
            };
        }

        // Vertex buffer setup
        const blit = (() => {
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);

            return (destination) => {
                gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }
        })();

        // Pointer handling
        class Pointer {
            constructor() {
                this.id = -1;
                this.texcoordX = 0;
                this.texcoordY = 0;
                this.prevTexcoordX = 0;
                this.prevTexcoordY = 0;
                this.deltaX = 0;
                this.deltaY = 0;
                this.down = false;
                this.moved = false;
                this.color = { r: 0.2, g: 0.5, b: 0.8 };
            }

            updatePosition(x, y) {
                this.prevTexcoordX = this.texcoordX;
                this.prevTexcoordY = this.texcoordY;
                this.texcoordX = x / canvas.width;
                this.texcoordY = 1.0 - y / canvas.height;
                this.deltaX = this.correctDeltaX(this.texcoordX - this.prevTexcoordX);
                this.deltaY = this.correctDeltaY(this.texcoordY - this.prevTexcoordY);
                this.moved = Math.abs(this.deltaX) > 0 || Math.abs(this.deltaY) > 0;
            }

            correctDeltaX(delta) {
                const aspectRatio = canvas.width / canvas.height;
                if (aspectRatio < 1) delta *= aspectRatio;
                return delta;
            }

            correctDeltaY(delta) {
                const aspectRatio = canvas.width / canvas.height;
                if (aspectRatio > 1) delta /= aspectRatio;
                return delta;
            }
        }

        // Event handlers
        const pointer = new Pointer();
        pointers.push(pointer);

        // Mouse events
        canvas.addEventListener('mousemove', e => {
            pointer.updatePosition(e.offsetX, e.offsetY);
            
            // Check hover über Elemente
            const elements = document.elementsFromPoint(e.clientX, e.clientY);
            let colorChanged = false;
            
            for (const element of elements) {
                if (element.dataset.color) {
                    const color = hexToRgb(element.dataset.color);
                    config.currentColor = color;
                    pointer.color = color;
                    colorChanged = true;
                    break;
                }
            }
            
            if (!colorChanged) {
                // Zurück zur Standard-Farbe
                config.currentColor = { r: 0.2, g: 0.5, b: 0.8 };
                pointer.color = config.currentColor;
            }
        });

        canvas.addEventListener('mousedown', () => {
            pointer.down = true;
        });

        window.addEventListener('mouseup', () => {
            pointer.down = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touches = e.targetTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const pointer = new Pointer();
                pointer.id = touch.identifier;
                pointer.updatePosition(touch.pageX, touch.pageY);
                pointer.down = true;
                pointers.push(pointer);
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touches = e.targetTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const pointer = pointers.find(p => p.id === touch.identifier);
                if (pointer) {
                    pointer.updatePosition(touch.pageX, touch.pageY);
                }
            }
        }, false);

        canvas.addEventListener('touchend', e => {
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const pointer = pointers.find(p => p.id === touch.identifier);
                if (pointer) {
                    pointer.down = false;
                }
            }
        });

        // Controls
        document.getElementById('toggle-effect').addEventListener('click', () => {
            config.PAUSED = !config.PAUSED;
            document.getElementById('toggle-effect').textContent = config.PAUSED ? 'Effekt fortsetzen' : 'Effekt pausieren';
        });

        document.getElementById('clear-canvas').addEventListener('click', () => {
            dye.read = resizeFBO(dye.read, config.DYE_RESOLUTION, config.DYE_RESOLUTION, ext.formatRGBA.internalFormat, ext.formatRGBA.format, ext.halfFloatTexType, ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST);
        });

        // Helper functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : null;
        }

        // Update loop
        let lastUpdateTime = Date.now();

        function update() {
            const dt = Math.min((Date.now() - lastUpdateTime) / 1000, 0.016666);
            lastUpdateTime = Date.now();

            if (!config.PAUSED) {
                // Automatische Farbquellen um das Logo herum (optional)
                if (Math.random() < 0.005) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 150;
                    const x = 0.5 + Math.cos(angle) * radius / canvas.width;
                    const y = 0.5 + Math.sin(angle) * radius / canvas.height;
                    
                    splatStack.push({
                        x,
                        y,
                        dx: Math.cos(angle) * 0.001,
                        dy: Math.sin(angle) * 0.001,
                        color: config.currentColor
                    });
                }

                step(dt);
            }

            render();
            requestAnimationFrame(update);
        }

        function step(dt) {
            gl.disable(gl.BLEND);
            gl.viewport(0, 0, velocity.width, velocity.height);

            // Curl
            curlProgram.bind();
            gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
            blit(curl.fbo);

            // Vorticity
            vorticityProgram.bind();
            gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
            gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
            gl.uniform1f(vorticityProgram.uniforms.dt, dt);
            blit(velocity.write.fbo);
            velocity.swap();

            // Divergence
            divergenceProgram.bind();
            gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(divergenceProgram.uniforms.uMask, logoMask.attach(1));
            blit(divergence.fbo);

            // Pressure
            clearProgram.bind();
            gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
            gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
            blit(pressure.write.fbo);
            pressure.swap();

            pressureProgram.bind();
            gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
            gl.uniform1i(pressureProgram.uniforms.uMask, logoMask.attach(1));
            for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(2));
                blit(pressure.write.fbo);
                pressure.swap();
            }

            // Gradient subtract
            gradienSubtractProgram.bind();
            gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
            gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
            gl.uniform1i(gradienSubtractProgram.uniforms.uMask, logoMask.attach(2));
            blit(velocity.write.fbo);
            velocity.swap();

            // Advection
            advectionProgram.bind();
            gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            if (!ext.supportLinearFiltering)
                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
            const velocityId = velocity.read.attach(0);
            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
            gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
            gl.uniform1i(advectionProgram.uniforms.uMask, logoMask.attach(1));
            gl.uniform1f(advectionProgram.uniforms.dt, dt);
            gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
            blit(velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);

            if (!ext.supportLinearFiltering)
                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
            gl.uniform1i(advectionProgram.uniforms.uMask, logoMask.attach(2));
            gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
            blit(dye.write.fbo);
            dye.swap();
        }

        function render() {
            // Apply splats (Maus-Farbe)
            applySplats();

            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);

            gl.viewport(0, 0, canvas.width, canvas.height);

            displayProgram.bind();
            gl.uniform1i(displayProgram.uniforms.uTexture, dye.read.attach(0));
            gl.uniform1i(displayProgram.uniforms.uMask, logoMask.attach(1));
            blit(null);
        }

        function applySplats() {
            // Process pointer splats
            pointers.forEach(p => {
                if (p.moved) {
                    splat(p.texcoordX, p.texcoordY, p.deltaX, p.deltaY, p.color);
                    p.moved = false;
                }
            });

            // Process automatic splats
            for (let i = 0; i < splatStack.length; i++) {
                const s = splatStack[i];
                splat(s.x, s.y, s.dx, s.dy, s.color);
            }
            splatStack = [];
        }

        function splat(x, y, dx, dy, color) {
            gl.viewport(0, 0, velocity.width, velocity.height);
            splatProgram.bind();
            gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
            gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
            gl.uniform2f(splatProgram.uniforms.point, x, y);
            gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
            gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS);
            gl.uniform1i(splatProgram.uniforms.uMask, logoMask.attach(1));
            blit(velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);
            gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
            gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
            gl.uniform1i(splatProgram.uniforms.uMask, logoMask.attach(1));
            blit(dye.write.fbo);
            dye.swap();
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        initFramebuffers();
        createLogoMask();
        update();
    </script>
</body>
</html>